

+ DOA (Data Oriented Approach)
  + ソフトウェアとは、`データの流通機構`なので、どのようなプログラムが必要になるかは、`どのようなデータをどのようなフォーマットで設計するのか？`に依存する
  + POA (process oriented approach)は時代遅れ
+ 3層スキーマ (外部スキーマ、概念スキーマ、 内部スキーマ)
  + 外部スキーマ
    + ビューのこと
  + `概念スキーマ (論理設計)`
    + テーブル定義書のこと
    + 開発者が主に関心がある部分
  + `内部スキーマ (物理設計)`
    + データベースの物理配置設定
    + ハードウェアやDBMSのそれぞれの特徴に関して理解している必要がある
    + `インデックス定義`
      + 本の索引のようなイメージで、ある単語で調べると直接そのページに行ってくれるような感じで、探す手間が省ける (->パフォーマンスの向上に繋がる)
    + サイジング
      + 最も難易度の高いタスク
      + キャパシティ (データの規模)
      + パフォーマンス 
        + どれだけ速いか? (処理時間)
        + どれだけ多くの情報を処理できるか？ (スループット)




+ DBのカラム名の命名規則ベストプラクティス
  + キャメルケース
  + 判定用のフラグは`is_deleted`のようにする
    + `delete_flag`などのようにすると、onかoffどっちで削除なのか分からない
+ 正規化するべき場合とそうでない場合
  + 講座と受講者の関係性で、正規化せずに受講者がゼロだったら、講座テーブルも消えてしまう
    + この場合は、`正規化する`が正解
  + 商品購入履歴テーブルで、商品名と価格を正規化した商品テーブルから参照してしまうと、過去の購入した時点での商品名や価格も変動して、履歴が壊れてしまう
    + この場合は`正規化しない`が正解
+ 中間テーブルの命名
  + 二つのテーブル名をただ繋ぎ合わせるだけの命名はバッドプラクティス
    + https://qiita.com/tkawa/items/dc3e313021f32fd91ca6
  + 




+ PK (Primary Key)
  + テーブルのレコードを一意にするためのもの
+ FK (Foreign Key)
  + テーブル間のデータの整合性を保証する
  + 部署テーブル(親)と従業員テーブル(子)の例
    + 開発部に所属している従業員がいるなら、開発部のレコードは削除できない
    + 存在しない部署を指定した従業員レコードは作成できない
+ Unique Key (UK) 
  + PK以外で重複を禁止するカラムとして指定
  + 複数指定可能
  + emailとかpasswordとかによく設定する
  + Not Null制約をつけることでPKとして使用できる



# 20250108 index
+ `index`は以下の項目で構成されている
  + 1. 探すレコードをを識別するデータ項目
  + 2. 対象レコードの格納位置を示すポインタ
  + これらを利用して、データが格納されている位置に直接アクセスできる
+ どの項目にindexを貼るのか？
  + where区での検索が頻繁な列
  + 結合の条件で使用される外部キー
  + `カーディナリティ`が高い列
    + カーディナリティとは、特定の種類の列 (カラム) が持つ値の種類
      + idだとレコード数、genderだと2
    + ユニークに近い値を多く持つ
    + ex) genderだとカーディナリティが低い
+ indexを貼らない方がいい項目
  + genderなどのカーディナリティが低い列
+ 複合インデックス
  + 2つ以上のカラムを1つのindexとして定義
  + 効果を最大限発揮するために、基本的に先頭の列から並べて、where句でのカラムの指定順序がインデックスの順序と同じにする必要がある
  + 複数のカラムを1つのインデックスにまとめることで、ストレージの節約になる `indexの節約`
+ `B-treeインデックス`
  + 色々あるindexの中でオール4の秀才タイプ
  + 主要なDBMS(PostgreSQL, MySQLなど)ではデフォルトで使われる
  + データ量が少ない場合 (1万件以下) だと、全件検索とB-treeインデックスの処理速度に差がないため効果なし
  + 


